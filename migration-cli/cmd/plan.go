package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

var (
	planInput  string
	planOutput string
)

var planCmd = &cobra.Command{
	Use:   "plan",
	Short: "Generate a migration plan from scan output",
	Long: `Generate a migration plan that maps NGINX Ingress Controller resources
to their Gateway API equivalents. The plan can be reviewed and then applied
using the apply command or submitted to the NGF Console API.`,
	RunE: runPlan,
}

func init() {
	planCmd.Flags().StringVarP(&planInput, "input", "i", "scan-results.yaml", "input file from scan results")
	planCmd.Flags().StringVarP(&planOutput, "output", "o", "migration-plan.yaml", "output file for migration plan")
}

// planEntry is a lightweight representation of a scanned resource line from
// the scan results file.
type planEntry struct {
	kind       string
	apiVersion string
	name       string
	namespace  string
	sourceFile string
}

// targetForKind returns the target Gateway API kind for a given source kind.
func targetForKind(kind string) string {
	switch kind {
	case "Ingress":
		return "HTTPRoute"
	case "VirtualServer":
		return "HTTPRoute"
	case "VirtualServerRoute":
		return "HTTPRoute"
	case "TransportServer":
		return "TCPRoute"
	default:
		return "Unknown"
	}
}

// targetAPIVersion returns the target Gateway API apiVersion for a source kind.
func targetAPIVersion(kind string) string {
	switch kind {
	case "Ingress", "VirtualServer", "VirtualServerRoute":
		return "gateway.networking.k8s.io/v1"
	case "TransportServer":
		return "gateway.networking.k8s.io/v1alpha2"
	default:
		return "gateway.networking.k8s.io/v1"
	}
}

// confidenceForKind returns a migration confidence level for the source kind.
func confidenceForKind(kind string) string {
	switch kind {
	case "Ingress":
		return "high"
	case "VirtualServer":
		return "medium"
	case "VirtualServerRoute":
		return "medium"
	case "TransportServer":
		return "low"
	default:
		return "low"
	}
}

func runPlan(_ *cobra.Command, _ []string) error {
	entries, err := parseScanResults(planInput)
	if err != nil {
		return fmt.Errorf("failed to read scan results: %w", err)
	}

	if len(entries) == 0 {
		fmt.Println("No resources found in scan results. Nothing to plan.")
		return nil
	}

	fmt.Printf("Generating migration plan for %d resource(s)...\n", len(entries))

	out, err := os.Create(planOutput)
	if err != nil {
		return fmt.Errorf("cannot create output file %q: %w", planOutput, err)
	}
	defer out.Close()

	fmt.Fprintln(out, "# ngf-migrate migration plan")
	fmt.Fprintln(out, "# Generated by: ngf-migrate plan")
	fmt.Fprintf(out, "# Source: %s\n", planInput)
	fmt.Fprintf(out, "# Total mappings: %d\n", len(entries))
	fmt.Fprintln(out, "")

	// Write a Gateway resource that the routes will attach to.
	fmt.Fprintln(out, "gateway:")
	fmt.Fprintln(out, "  name: migrated-gateway")
	fmt.Fprintln(out, "  namespace: default")
	fmt.Fprintln(out, "  gatewayClassName: nginx")
	fmt.Fprintln(out, "  listeners:")
	fmt.Fprintln(out, "    - name: http")
	fmt.Fprintln(out, "      port: 80")
	fmt.Fprintln(out, "      protocol: HTTP")
	fmt.Fprintln(out, "    - name: https")
	fmt.Fprintln(out, "      port: 443")
	fmt.Fprintln(out, "      protocol: HTTPS")
	fmt.Fprintln(out, "")

	fmt.Fprintln(out, "mappings:")
	for _, e := range entries {
		target := targetForKind(e.kind)
		targetAPI := targetAPIVersion(e.kind)
		confidence := confidenceForKind(e.kind)

		fmt.Fprintln(out, "  - source:")
		fmt.Fprintf(out, "      kind: %s\n", e.kind)
		fmt.Fprintf(out, "      apiVersion: %s\n", e.apiVersion)
		fmt.Fprintf(out, "      name: %s\n", e.name)
		fmt.Fprintf(out, "      namespace: %s\n", e.namespace)
		if e.sourceFile != "" {
			fmt.Fprintf(out, "      sourceFile: %s\n", e.sourceFile)
		}
		fmt.Fprintln(out, "    target:")
		fmt.Fprintf(out, "      kind: %s\n", target)
		fmt.Fprintf(out, "      apiVersion: %s\n", targetAPI)
		fmt.Fprintf(out, "      name: %s\n", e.name)
		fmt.Fprintf(out, "      namespace: %s\n", e.namespace)
		fmt.Fprintf(out, "    confidence: %s\n", confidence)

		// Add relevant notes.
		switch confidence {
		case "high":
			fmt.Fprintln(out, "    notes:")
			fmt.Fprintln(out, "      - Direct mapping available")
		case "medium":
			fmt.Fprintln(out, "    notes:")
			fmt.Fprintln(out, "      - Most features map directly; some annotations need review")
		case "low":
			fmt.Fprintln(out, "    notes:")
			fmt.Fprintln(out, "      - Manual review required; limited Gateway API support")
		}
	}

	fmt.Printf("\nMigration plan generated with %d mapping(s).\n", len(entries))
	fmt.Printf("Plan written to %s\n", planOutput)
	fmt.Println("\nNext step: review the plan, then run 'ngf-migrate apply -p", planOutput+"'")

	return nil
}

// parseScanResults reads the scan results file and extracts resource entries.
// It uses simple line-based parsing to avoid external YAML dependencies.
func parseScanResults(path string) ([]planEntry, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var entries []planEntry
	scanner := bufio.NewScanner(f)

	inResources := false
	var current *planEntry

	flush := func() {
		if current != nil && current.kind != "" {
			entries = append(entries, *current)
		}
		current = nil
	}

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Skip comments and blank lines.
		if strings.HasPrefix(trimmed, "#") || trimmed == "" {
			continue
		}

		// Detect the resources: section.
		if trimmed == "resources:" {
			inResources = true
			continue
		}

		// Detect other top-level sections to leave resources block.
		if !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") && strings.HasSuffix(trimmed, ":") && trimmed != "resources:" {
			if inResources {
				flush()
			}
			inResources = false
			continue
		}

		if !inResources {
			continue
		}

		// New list item starts with "- ".
		if strings.HasPrefix(trimmed, "- ") {
			flush()
			current = &planEntry{}
			// The first field may be on the same line as "-".
			field := strings.TrimPrefix(trimmed, "- ")
			parseField(current, field)
			continue
		}

		// Continuation field inside a list item.
		if current != nil {
			parseField(current, trimmed)
		}
	}

	flush()

	if err := scanner.Err(); err != nil {
		return entries, err
	}

	return entries, nil
}

// parseField assigns a "key: value" line to the correct planEntry field.
func parseField(e *planEntry, field string) {
	parts := strings.SplitN(field, ":", 2)
	if len(parts) != 2 {
		return
	}
	key := strings.TrimSpace(parts[0])
	val := strings.TrimSpace(parts[1])
	val = strings.Trim(val, "\"'")

	switch key {
	case "kind":
		e.kind = val
	case "apiVersion":
		e.apiVersion = val
	case "name":
		e.name = val
	case "namespace":
		e.namespace = val
	case "sourceFile":
		e.sourceFile = val
	}
}
