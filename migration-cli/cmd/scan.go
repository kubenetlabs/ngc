package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

var (
	scanInput  string
	scanOutput string
)

var scanCmd = &cobra.Command{
	Use:   "scan",
	Short: "Discover NGINX Ingress Controller resources in YAML files",
	Long: `Scan YAML files for Ingress, VirtualServer, VirtualServerRoute, and
TransportServer resources. The discovered resources are written to an output
file for use by the plan command.

Provide a single YAML file or a directory of YAML files via the -i flag.
If no input is specified, the current directory is scanned.`,
	RunE: runScan,
}

func init() {
	scanCmd.Flags().StringVarP(&scanInput, "input", "i", ".", "input YAML file or directory to scan")
	scanCmd.Flags().StringVarP(&scanOutput, "output", "o", "scan-results.yaml", "output file for scan results")
}

// resourceEntry holds discovered resource metadata from a YAML document.
type resourceEntry struct {
	kind       string
	apiVersion string
	name       string
	namespace  string
	file       string
}

func runScan(_ *cobra.Command, _ []string) error {
	info, err := os.Stat(scanInput)
	if err != nil {
		return fmt.Errorf("cannot access input path %q: %w", scanInput, err)
	}

	var files []string
	if info.IsDir() {
		entries, err := os.ReadDir(scanInput)
		if err != nil {
			return fmt.Errorf("cannot read directory %q: %w", scanInput, err)
		}
		for _, e := range entries {
			if e.IsDir() {
				continue
			}
			ext := strings.ToLower(filepath.Ext(e.Name()))
			if ext == ".yaml" || ext == ".yml" {
				files = append(files, filepath.Join(scanInput, e.Name()))
			}
		}
		if len(files) == 0 {
			fmt.Println("No YAML files found in", scanInput)
			return nil
		}
	} else {
		files = []string{scanInput}
	}

	fmt.Printf("Scanning %d file(s) for NGINX Ingress Controller resources...\n", len(files))

	var resources []resourceEntry
	for _, f := range files {
		found, err := scanFile(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "warning: skipping %s: %v\n", f, err)
			continue
		}
		resources = append(resources, found...)
	}

	// Tally by kind.
	counts := make(map[string]int)
	for _, r := range resources {
		counts[r.kind]++
	}

	// Write results.
	out, err := os.Create(scanOutput)
	if err != nil {
		return fmt.Errorf("cannot create output file %q: %w", scanOutput, err)
	}
	defer out.Close()

	fmt.Fprintln(out, "# ngf-migrate scan results")
	fmt.Fprintln(out, "# Generated by: ngf-migrate scan")
	fmt.Fprintf(out, "# Input: %s\n", scanInput)
	fmt.Fprintf(out, "# Total resources: %d\n", len(resources))
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "summary:")
	fmt.Fprintf(out, "  totalResources: %d\n", len(resources))
	fmt.Fprintln(out, "  byKind:")
	for kind, count := range counts {
		fmt.Fprintf(out, "    %s: %d\n", kind, count)
	}
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "resources:")
	for _, r := range resources {
		fmt.Fprintln(out, "  - kind:", r.kind)
		fmt.Fprintln(out, "    apiVersion:", r.apiVersion)
		fmt.Fprintln(out, "    name:", r.name)
		fmt.Fprintln(out, "    namespace:", r.namespace)
		fmt.Fprintln(out, "    sourceFile:", r.file)
	}

	fmt.Printf("\nScan complete. Found %d resource(s):\n", len(resources))
	for kind, count := range counts {
		fmt.Printf("  %s: %d\n", kind, count)
	}
	fmt.Printf("Results written to %s\n", scanOutput)

	return nil
}

// scanFile reads a YAML file and extracts resource metadata by looking for
// kind: and apiVersion: lines. It splits on "---" document separators.
func scanFile(path string) ([]resourceEntry, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var entries []resourceEntry
	scanner := bufio.NewScanner(f)

	// Track state for the current YAML document.
	var kind, apiVersion, name, namespace string
	inMetadata := false
	docIdx := 0

	flush := func() {
		if kind == "" {
			return
		}
		// Only keep kinds we care about.
		switch kind {
		case "Ingress", "VirtualServer", "VirtualServerRoute", "TransportServer":
		default:
			return
		}
		if name == "" {
			name = fmt.Sprintf("%s-%d", strings.ToLower(kind), docIdx+1)
		}
		if namespace == "" {
			namespace = "default"
		}
		entries = append(entries, resourceEntry{
			kind:       kind,
			apiVersion: apiVersion,
			name:       name,
			namespace:  namespace,
			file:       path,
		})
		docIdx++
	}

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Document separator — flush the current document.
		if trimmed == "---" {
			flush()
			kind, apiVersion, name, namespace = "", "", "", ""
			inMetadata = false
			continue
		}

		// Top-level fields (no leading whitespace).
		if !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") {
			if strings.HasPrefix(trimmed, "kind:") {
				kind = strings.TrimSpace(strings.TrimPrefix(trimmed, "kind:"))
				kind = strings.Trim(kind, "\"'")
				inMetadata = false
			} else if strings.HasPrefix(trimmed, "apiVersion:") {
				apiVersion = strings.TrimSpace(strings.TrimPrefix(trimmed, "apiVersion:"))
				apiVersion = strings.Trim(apiVersion, "\"'")
				inMetadata = false
			} else if trimmed == "metadata:" {
				inMetadata = true
			} else {
				inMetadata = false
			}
			continue
		}

		// Inside metadata block — look for name and namespace.
		if inMetadata {
			if strings.HasPrefix(trimmed, "name:") {
				name = strings.TrimSpace(strings.TrimPrefix(trimmed, "name:"))
				name = strings.Trim(name, "\"'")
			} else if strings.HasPrefix(trimmed, "namespace:") {
				namespace = strings.TrimSpace(strings.TrimPrefix(trimmed, "namespace:"))
				namespace = strings.Trim(namespace, "\"'")
			}
		}
	}

	// Flush the last document (files may not end with ---).
	flush()

	if err := scanner.Err(); err != nil {
		return entries, fmt.Errorf("error reading %s: %w", path, err)
	}

	return entries, nil
}
